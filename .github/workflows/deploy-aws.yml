name: Deploy to AWS

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
    types: [closed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  TERRAFORM_VERSION: 1.6.0

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      deploy_strategy: ${{ steps.strategy.outputs.strategy }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi
      
      - name: Determine Strategy
        id: strategy
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "strategy=${{ github.event.inputs.deployment_strategy }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.env.outputs.environment }}" = "production" ]; then
            echo "strategy=blue-green" >> $GITHUB_OUTPUT
          else
            echo "strategy=rolling" >> $GITHUB_OUTPUT
          fi

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install security tools
        run: |
          pip install safety bandit semgrep

      - name: Run Safety check
        run: |
          cd backend
          safety check -r requirements.txt --json --output safety-report.json || true

      - name: Run Bandit security scan
        run: |
          cd backend
          bandit -r src/ -f json -o bandit-report.json || true

      - name: Run Semgrep scan
        run: |
          semgrep --config=auto --json --output=semgrep-report.json . || true

      - name: Upload security reports
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            backend/safety-report.json
            backend/bandit-report.json
            semgrep-report.json

  build-and-test:
    runs-on: ubuntu-latest
    needs: security-scan
    strategy:
      matrix:
        service: [backend, frontend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and test backend
        if: matrix.service == 'backend'
        run: |
          cd backend
          
          # Install dependencies
          pip install -r requirements.txt
          
          # Run tests
          python -m pytest tests/ -v --cov=src --cov-report=xml
          
          # Build Docker image
          docker build -t $ECR_REGISTRY/qenergyz/backend:${{ github.sha }} .
          docker build -t $ECR_REGISTRY/qenergyz/backend:latest .

      - name: Build and test frontend
        if: matrix.service == 'frontend'
        run: |
          cd frontend
          
          # Install dependencies
          npm ci
          
          # Run linting
          npm run lint
          
          # Run tests
          npm run test -- --coverage --watchAll=false
          
          # Build production bundle
          npm run build
          
          # Build Docker image
          docker build -t $ECR_REGISTRY/qenergyz/frontend:${{ github.sha }} .
          docker build -t $ECR_REGISTRY/qenergyz/frontend:latest .

      - name: Push Docker image
        run: |
          docker push $ECR_REGISTRY/qenergyz/${{ matrix.service }}:${{ github.sha }}
          docker push $ECR_REGISTRY/qenergyz/${{ matrix.service }}:latest

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        if: matrix.service == 'backend'
        with:
          file: ./backend/coverage.xml
          flags: backend

  terraform-plan:
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-test]
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        run: |
          cd infrastructure/terraform/aws
          terraform init

      - name: Terraform Plan
        id: plan
        run: |
          cd infrastructure/terraform/aws
          terraform plan \
            -var="environment=${{ needs.determine-environment.outputs.environment }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="sentry_dsn=${{ secrets.SENTRY_DSN }}" \
            -var="stripe_api_key=${{ secrets.STRIPE_API_KEY }}" \
            -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan-${{ needs.determine-environment.outputs.environment }}
          path: infrastructure/terraform/aws/tfplan

  deploy:
    runs-on: ubuntu-latest
    needs: [determine-environment, terraform-plan]
    environment: ${{ needs.determine-environment.outputs.environment }}
    if: github.event_name != 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-${{ needs.determine-environment.outputs.environment }}
          path: infrastructure/terraform/aws/

      - name: Terraform Init
        run: |
          cd infrastructure/terraform/aws
          terraform init

      - name: Terraform Apply
        id: apply
        run: |
          cd infrastructure/terraform/aws
          terraform apply -auto-approve tfplan

      - name: Get Infrastructure Outputs
        id: tf-outputs
        run: |
          cd infrastructure/terraform/aws
          echo "ecs_cluster=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "alb_dns=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

  deploy-application:
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy with Rolling Strategy
        if: needs.determine-environment.outputs.deploy_strategy == 'rolling'
        run: |
          # Update ECS service with new image
          aws ecs update-service \
            --cluster qenergyz-${{ needs.determine-environment.outputs.environment }} \
            --service qenergyz-backend \
            --force-new-deployment

      - name: Deploy with Blue-Green Strategy
        if: needs.determine-environment.outputs.deploy_strategy == 'blue-green'
        run: |
          # Implement blue-green deployment logic
          echo "Implementing blue-green deployment..."
          
          # Create new task definition with new image
          # Update service to use new task definition
          # Wait for health checks
          # Update load balancer target groups
          
      - name: Deploy with Canary Strategy
        if: needs.determine-environment.outputs.deploy_strategy == 'canary'
        run: |
          # Implement canary deployment logic
          echo "Implementing canary deployment..."
          
          # Deploy to a subset of instances
          # Monitor metrics for configured time
          # Gradually increase traffic to new version

      - name: Run Database Migrations
        run: |
          # Run database migrations
          aws ecs run-task \
            --cluster qenergyz-${{ needs.determine-environment.outputs.environment }} \
            --task-definition qenergyz-migration-task \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx],assignPublicIp=ENABLED}"

      - name: Run Health Checks
        run: |
          # Wait for application to be healthy
          timeout=600
          interval=30
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if curl -f "http://${{ steps.tf-outputs.outputs.alb_dns }}/health"; then
              echo "Application is healthy!"
              exit 0
            fi
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          echo "Health check failed after $timeout seconds"
          exit 1

      - name: Update Monitoring
        run: |
          # Update monitoring dashboards and alerts for new deployment
          aws cloudwatch put-dashboard \
            --dashboard-name "Qenergyz-${{ needs.determine-environment.outputs.environment }}" \
            --dashboard-body file://monitoring/cloudwatch-dashboard.json

  post-deployment:
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-application]
    if: always()
    steps:
      - name: Send Slack Notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          username: 'GitHub Actions'
          text: |
            Deployment to ${{ needs.determine-environment.outputs.environment }} completed!
            Status: ${{ job.status }}
            Environment: ${{ needs.determine-environment.outputs.environment }}
            Strategy: ${{ needs.determine-environment.outputs.deploy_strategy }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Update Deployment Status
        run: |
          # Update deployment tracking system
          echo "Deployment completed with status: ${{ job.status }}"